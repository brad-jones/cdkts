import type { Construct } from "../../construct.ts";
import { Block } from "../block.ts";
import type { Provider } from "../providers/provider.ts";

/**
 * Represents a Terraform/OpenTofu data source block.
 *
 * Data sources allow Terraform to fetch and compute data from external sources or providers.
 * Unlike resources, data sources are read-only and do not create or manage infrastructure.
 * They are useful for referencing information defined outside of Terraform, computed by
 * other Terraform configurations, or dynamically generated by providers.
 *
 * @template Self - The concrete data source class type (use `typeof YourDataSource`)
 *
 * @see https://developer.hashicorp.com/terraform/language/data-sources
 * @also https://opentofu.org/docs/language/data-sources
 *
 * @example
 * ```typescript
 * // Basic data source
 * class AwsAmiDataSource extends DataSource<typeof AwsAmiDataSource> {
 *   static override readonly Props = class extends DataSource.Props {
 *     owners = new DataSource.Input<string[]>();
 *     mostRecent = new DataSource.Input<boolean | undefined>();
 *     id = new DataSource.Output<string>();
 *   };
 *
 *   constructor(parent: Construct, label: string, inputs: AwsAmiDataSource["inputs"]) {
 *     super(parent, "aws_ami", label, inputs);
 *   }
 * }
 *
 * // Usage
 * const ami = new AwsAmiDataSource(stack, "ubuntu", {
 *   owners: ["099720109477"],
 *   mostRecent: true,
 * });
 * const imageId = ami.outputs.id;
 * ```
 */
export class DataSource<Self = typeof DataSource> extends Block<Self> {
  /**
   * Configuration properties for a DataSource block.
   *
   * Defines the base schema for data source configuration. Concrete data source classes
   * typically extend this to add provider-specific properties and output attributes.
   */
  static override readonly Props = class extends Block.Props {
    /**
     * The count meta-argument instructs Terraform to create multiple instances of the
     * data source using the same configuration.
     *
     * @see https://developer.hashicorp.com/terraform/language/data-sources#count
     */
    count = new Block.Input<number | undefined>();

    /**
     * Specifies explicit dependencies on other resources or data sources.
     *
     * Use this to ensure the data source is read after specific resources are created
     * or other data sources are queried, establishing an execution order dependency.
     *
     * @see https://developer.hashicorp.com/terraform/language/data-sources#depends_on
     */
    dependsOn = new Block.Input<Block[] | undefined>();

    /**
     * The for_each meta-argument instructs Terraform to create multiple instances of
     * the data source, once for each member of a list or key-value pair in a map.
     *
     * @see https://developer.hashicorp.com/terraform/language/data-sources#for_each
     */
    forEach = new Block.Input<Record<string, string> | string[] | undefined>();

    /**
     * The provider argument instructs Terraform to use an alternate provider
     * configuration to query this data source.
     *
     * Use this when you need to query data from a different region, account,
     * or provider configuration than the default.
     *
     * @see https://developer.hashicorp.com/terraform/language/data-sources#provider
     */
    provider = new Block.Input<Provider | undefined>();

    /**
     * Lifecycle validation conditions for the data source.
     *
     * Each condition specifies when it should be evaluated (pre or post),
     * a boolean condition expression, and an error message to display if
     * the condition fails. Useful for enforcing constraints on data source
     * queries and their results.
     *
     * @see https://developer.hashicorp.com/terraform/language/data-sources#lifecycle
     */
    lifecycles = new Block.Input<{ when: "pre" | "post"; condition: string; errorMessage: string }[] | undefined>();
  };

  /**
   * Creates a new DataSource block.
   *
   * @param parent - The parent construct that will contain this data source
   * @param typeName - The provider-specific data source type (e.g., "aws_ami", "google_compute_image")
   * @param label - A unique identifier for this data source instance within its parent scope
   * @param inputs - Configuration inputs for the data source, including meta-arguments and provider-specific properties
   * @param childBlocks - Optional callback to define additional nested blocks within the data source
   *
   * @example
   * ```typescript
   * // Simple data source
   * new DataSource(stack, "aws_vpc", "main", {
   *   default: true,
   * });
   *
   * // Data source with lifecycle conditions
   * new DataSource(stack, "aws_ami", "validated", {
   *   owners: ["self"],
   *   lifecycles: [{
   *     when: "post",
   *     condition: "self.architecture == 'x86_64'",
   *     errorMessage: "AMI must be x86_64 architecture",
   *   }],
   * });
   * ```
   */
  constructor(
    parent: Construct,
    readonly typeName: string,
    readonly label: string,
    inputs: DataSource["inputs"],
    childBlocks?: (b: Block) => void,
  ) {
    super(parent, "data", [typeName, label], inputs, childBlocks);

    if (inputs?.lifecycles && inputs.lifecycles.length > 0) {
      new Block(this, "lifecycle", [], {}, (b) => {
        for (const lifecycle of inputs!.lifecycles!) {
          new Block(b, `${lifecycle.when}condition`, [], {
            condition: lifecycle.condition,
            error_message: lifecycle.errorMessage,
          });
        }
      });
    }
  }

  /**
   * Maps data source inputs to HCL format by filtering out the lifecycles input.
   *
   * The lifecycles input is handled separately as nested precondition/postcondition
   * blocks rather than an inline property, so it must be excluded from the main
   * inputs object during HCL serialization.
   *
   * @returns The inputs object without the lifecycles property
   */
  protected override mapInputsForHcl(): unknown {
    const inputs = { ...this.inputs };
    delete inputs["lifecycles"];
    return inputs;
  }
}
